"use strict";

// External modules.
var Store = require('eventstore').Store;
var _ = require('lodash');
var r = require('rethinkdb');
var debug = require('debug')('eventstore:store:rethinkdb');;

// System modules.
var util = require('util');

function Rethink(options) {
  options = options || {};
  Store.call(this, options);

  var defaults = {
    host: 'localhost',
    port: 28015,
    dbName: 'eventstore',
    eventsCollectionName: 'events',
    snapshotsCollectionName: 'snapshots',
    transactionsCollectionName: 'transactions'
  };

  _.defaults(options, defaults);
  this.options = options;
}

util.inherits(Rethink, Store);

_.extend(Rethink.prototype, {
  
  connect: function (callback) {
    var self = this;
    var options = this.options;
    debug(options);
    r.connect({
      host: options.host,
      port: options.port,
      timeout: options.timeout/1000
    }, function(err, conn) {
      if (err) {
        debug(err);
        if (callback) callback(err);
        return;
      } else {
        self.conn = conn;
        self.emit('connect');
        if (callback) callback(null, self); 
        return;
      }
    });
  },
  
  disconnect: function(callback) {
    var self = this;
    self.conn.close()
    .then(function() {
      this.emit('disconnect');
      if (callback) callback(null, self);
      return;
    })
    .error(function(err) {
      debug(err);
      if (callback) callback(err);
      return;
    });
  },
  
  getNewId: function(callback) {
    var self = this;
    r.uuid().run(self.db, callback);
  },
  
  addEvents: function (events, callback) {
    if (events.length === 0) {
      if (callback) { callback(null); }
      return;
    }

    var commitId = events[0].commitId;

    var noAggregateId = false,
      invalidCommitId = false;

    _.forEach(events, function (evt) {
      if (!evt.aggregateId) {
        noAggregateId = true;
      }

      if (!evt.commitId || evt.commitId !== commitId) {
        invalidCommitId = true;
      }

      evt._id = evt.id;
      evt.dispatched = false;
    });

    if (noAggregateId) {
      var errMsg = 'aggregateId not defined!';
      debug(errMsg);
      if (callback) callback(new Error(errMsg));
      return;
    }

    if (invalidCommitId) {
      var errMsg = 'commitId not defined or different!';
      debug(errMsg);
      if (callback) callback(new Error(errMsg));
      return;
    }

    var self = this;

    if (events.length === 1) {
      return this.events.insert(events, callback);
    }

    var tx = {
      _id: commitId,
      events: events,
      aggregateId: events[0].aggregateId,
      aggregate: events[0].aggregate,
      context: events[0].context
    };

    this.transactions.insert(tx, function (err) {
      if (err) {
        debug(err);
        if (callback) callback(err);
        return;
      }

      self.events.insert(events, function (err) {
        if (err) {
          debug(err);
          if (callback) callback(err);
          return;
        }

        self.removeTransactions(events[events.length - 1]);

        if (callback) { callback(null); }
      });
    });
  }
  
});

module.exports = Rethink;